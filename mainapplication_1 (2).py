# -*- coding: utf-8 -*-
"""MainApplication-1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mh8yDRmuUtIGspm2KxRjUXyEIvHms2Q9
"""

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import ta
from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer
from GoogleNews import GoogleNews
import datetime

def fetch_google_news(stock_name, days=3):
    googlenews = GoogleNews(lang='en')
    end = datetime.date.today()
    start = end - datetime.timedelta(days=days)
    googlenews.set_time_range(start.strftime('%m/%d/%Y'), end.strftime('%m/%d/%Y'))
    googlenews.search(stock_name)

    headlines = []
    for page in range(1, 3):  # you can increase this for more results
        googlenews.get_page(page)
        articles = googlenews.results()
        headlines.extend([a['title'] for a in articles])
    return list(set(headlines))  # remove duplicates

def analyze_sentiment(texts):
    analyzer = SentimentIntensityAnalyzer()
    results = []
    for text in texts:
        score = analyzer.polarity_scores(text)
        results.append({
            'text': text,
            'compound': score['compound'],
            'sentiment': 'Positive' if score['compound'] > 0.1 else 'Negative' if score['compound'] < -0.1 else 'Neutral'
        })
    return pd.DataFrame(results)

def stock_sentiment_score(stock_name):
    print(f"\nðŸ” Fetching news for: {stock_name}")
    headlines = fetch_google_news(stock_name + " stock")

    print(f"ðŸ“° {len(headlines)} headlines fetched")
    if not headlines:
        return "No data available."

    df = analyze_sentiment(headlines)
    print("\nðŸ“Š Sample Headlines and Sentiment:")
    print(df[['text', 'sentiment']].head())

    # Scoring System
    sentiment_counts = df['sentiment'].value_counts(normalize=True)
    score = (
        sentiment_counts.get('Positive', 0) * 1 +
        sentiment_counts.get('Neutral', 0) * 0 +
        sentiment_counts.get('Negative', 0) * -1
    ) * 100

    print(f"\nðŸ“ˆ Sentiment Score for {stock_name}: {round(score, 2)}")
    return df, round(score, 2)

# Risk-free rate and market index
risk_free_rate = 0.06 / 252  # Daily rate
market_index = '^NSEI'

# Get market return data
market_data = yf.download(market_index, period='1y')
market_data['Market Return'] = market_data['Close'].pct_change()

results = []

# Modified get_stock_ratios function
def get_stock_ratios(ticker):
    try:
        # Get stock info and history
        stock = yf.Ticker(ticker)
        info = stock.info

        pe_ratio = info.get('trailingPE')
        pb_ratio = info.get('priceToBook')
        roe = info.get('returnOnEquity')
        beta = info.get('beta')

        # Historical price data
        hist = stock.history(period='1y')
        hist['Return'] = hist['Close'].pct_change()

        # Calculate Sharpe Ratio
        # Ensure there's data and variation to avoid division by zero or NaN
        sharpe_ratio = np.nan
        if not hist['Return'].isnull().all() and hist['Return'].std() != 0:
            excess_return = hist['Return'] - risk_free_rate
            sharpe_ratio = np.sqrt(252) * excess_return.mean() / excess_return.std()


        # Calculate Treynor Ratio
        treynor_ratio = np.nan
        # Ensure beta is not None or zero, and there's historical data
        if beta is not None and beta != 0 and not hist['Return'].isnull().all():
            treynor_ratio = (hist['Return'].mean() - risk_free_rate) * 252 / beta

        # Create the dictionary for the current ticker
        ticker_ratios = {
            'Ticker': ticker,
            'P/E Ratio': pe_ratio,
            'P/B Ratio': pb_ratio,
            'ROE': roe,
            'Beta': beta,
            'Sharpe Ratio': sharpe_ratio,
            'Treynor Ratio': treynor_ratio
        }

        # Append to results list (optional, depending on if you need the list later)
        results.append(ticker_ratios)

        # Return the dictionary for the current ticker
        return ticker_ratios

    except Exception as e:
        print(f"Error fetching data for {ticker}: {e}")
        # Return None in case of an error
        return None

def gettechnical_indicators(ticker):
    df = yf.download(ticker, period='1y', interval='1d')
    df.dropna(inplace=True)

    close_series = df['Close']
    if isinstance(close_series, pd.DataFrame):
      close_series = close_series.squeeze()

      # Fix multi-dimensional case


    # EMA 50 & EMA 100
    df['EMA_50'] = ta.trend.EMAIndicator(close=close_series, window=50).ema_indicator()
    df['EMA_100'] = ta.trend.EMAIndicator(close=close_series, window=100).ema_indicator()

    # RSI
    df['RSI'] = ta.momentum.RSIIndicator(close=close_series, window=14).rsi()

    # MACD & Signal
    macd = ta.trend.MACD(close=close_series)
    df['MACD'] = macd.macd()
    df['MACD_Signal'] = macd.macd_signal()

    # Bollinger Bands
    bb = ta.volatility.BollingerBands(close=close_series, window=20, window_dev=2)
    df['BB_Upper'] = bb.bollinger_hband()
    df['BB_Middle'] = bb.bollinger_mavg()
    df['BB_Lower'] = bb.bollinger_lband()

    latest = df.iloc[-1]
    close = latest['Close'].iloc[-1]
    ema_50 = latest['EMA_50'].iloc[-1]
    ema_100 = latest['EMA_100'].iloc[-1]
    rsi = latest['RSI'].iloc[-1]
    macd_val = latest['MACD'].iloc[-1]
    macd_signal = latest['MACD_Signal'].iloc[-1]
    bb_upper = latest['BB_Upper'].iloc[-1]
    bb_middle = latest['BB_Middle'].iloc[-1]
    bb_lower = latest['BB_Lower'].iloc[-1]

    # 1. Close > EMA 50
    close_gt_ema50 = int(close > ema_50)

    # 2. EMA 50 > EMA 100
    ema50_gt_ema100 = int(ema_50 > ema_100)

    # 3. RSI Condition
    if rsi > 70:
        rsi_status = "Overbought"
    elif rsi < 30:
        rsi_status = "Oversold"
    else:
        rsi_status = "Neutral"

    # 4. MACD > Signal
    macd_signal_result = int(macd_val > macd_signal)

    # 5. Bollinger Band Differences
    bb_upper_diff = close - bb_upper
    bb_middle_diff = close - bb_middle
    bb_lower_diff = close - bb_lower

    # Print Results
    print(df[['Close', 'EMA_50', 'EMA_100', 'RSI', 'MACD', 'MACD_Signal', 'BB_Upper', 'BB_Middle', 'BB_Lower']].iloc[-1])
    print(f"\nTechnical Summary for {ticker} as of {df.index[-1].date()}:\n")
    print(f"1. Close > EMA 50: {close_gt_ema50}")
    print(f"2. EMA 50 > EMA 100: {ema50_gt_ema100}")
    print(f"3. RSI ({rsi:.2f}): {rsi_status}")
    print(f"4. MACD > MACD Signal: {macd_signal_result}")
    print(f"5. Bollinger Band Differences:")
    print(f"   - Close - Upper Band:  {bb_upper_diff:.2f}")
    print(f"   - Close - Middle Band: {bb_middle_diff:.2f}")
    print(f"   - Close - Lower Band:  {bb_lower_diff:.2f}")

st.title("ðŸ“ˆ Indian Stock Analyzer")

stock_name = st.text_input("Enter Stock Name (e.g., RELIANCE):")
ticker = st.text_input("Enter Ticker Symbol (e.g., RELIANCE.NS):")

if st.button("Run Analysis"):
    if stock_name and ticker:
        st.subheader("ðŸ“Š Financial Ratios")
        ratios = get_stock_ratios(ticker)
        if ratios:
            st.write(pd.DataFrame([ratios]))

        st.subheader("ðŸ“° News Sentiment Analysis")
        sentiment_df, sentiment_score = stock_sentiment_score(stock_name)
        st.metric("Sentiment Score", sentiment_score)
        st.write(sentiment_df[['text', 'sentiment']])

        st.subheader("ðŸ“ˆ Technical Indicator Summary")
        try:
            tech_summary = get_technical_summary(ticker)
            st.dataframe(pd.DataFrame([tech_summary]))
        except Exception as e:
            st.error(f"Error generating technical summary: {e}")
    else:
        st.warning("Please enter both stock name and ticker symbol.")